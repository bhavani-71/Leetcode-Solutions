LeetCode #133 - Clone Graph  
ğŸ”— https://leetcode.com/problems/clone-graph/

---

ğŸŒ Graph Visualization:

    1
   / \
  2   4
   \ /
    3

ğŸ” Connections:
- Node 1 â†’ [2, 4]
- Node 2 â†’ [1, 3]
- Node 3 â†’ [2, 4]
- Node 4 â†’ [1, 3]

---

ğŸ§© Problem Statement:

Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.

Each node in the graph contains a value (`int`) and a list of its neighbors.

Constraints:
- The number of nodes in the graph is in the range [0, 100].
- 1 <= Node.val <= 100
- Node.val is unique for each node.
- The graph is connected and undirected.

---

ğŸ’¡ Example:

Input:
Node with val = 1  
Connections: 1â€“2, 1â€“4, 2â€“3, 3â€“4

Output:
A new graph that is structurally identical but made of new node instances.

---

ğŸª“ Brute Force Approach:

ğŸ” Approach:
- Thereâ€™s no real â€œbrute forceâ€ since cloning a graph requires traversal. But you can use DFS or BFS with a dictionary to keep track of already cloned nodes.

â±ï¸ Time Complexity: O(N + E)  
- N is number of nodes  
- E is number of edges

ğŸ§  Space Complexity: O(N)  
- To store the cloned nodes and recursion stack

---

ğŸš€ Optimized DFS Approach:

âœ… Strategy:
- Use a hash map to keep track of visited nodes (original â†’ clone).
- Perform DFS:
  - If the node is already cloned, return it.
  - Otherwise, clone the node and recursively clone all neighbors.

ğŸ§  Pseudocode:

clone_graph(node):  
â€ƒif node is None:  
â€ƒâ€ƒreturn None  
â€ƒif node in visited:  
â€ƒâ€ƒreturn visited[node]  
â€ƒ  
â€ƒcopy = Node(node.val)  
â€ƒvisited[node] = copy  
â€ƒ  
â€ƒfor neighbor in node.neighbors:  
â€ƒâ€ƒcopy.neighbors.append(clone_graph(neighbor))  
â€ƒ  
â€ƒreturn copy

â±ï¸ Time Complexity: O(N + E)  
ğŸ§  Space Complexity: O(N)

---

âœ… Code Trace:

Input Graph:
- 1 connects to [2, 4]
- 2 connects to [1, 3]
- 3 connects to [2, 4]
- 4 connects to [1, 3]

Steps:
- Start at Node 1 â†’ Clone Node 1
- Visit neighbor Node 2 â†’ Clone Node 2
- Visit neighbor Node 3 from 2 â†’ Clone Node 3
- Visit neighbor Node 4 from 3 â†’ Clone Node 4
- Backtrack and connect all neighbors

Each node is cloned only once and connections are re-established recursively.

---

âœ… Final Output:
Returns a deep-copied graph with same structure and values but different memory references.
