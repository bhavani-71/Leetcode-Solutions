https://leetcode.com/problems/word-break/

ğŸ§© Problem Statement:

Given a string `s` and a dictionary of words `wordDict`, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.

Each word in `wordDict` can be reused multiple times.  
Return `True` if such a segmentation is possible, otherwise return `False`.

---

ğŸª“ Brute Force Approach (Recursion without memoization):

ğŸ” Approach:
- Try every possible prefix of `s`.
- If the prefix is in the dictionary, recursively check the remaining suffix.
- If any path leads to successful segmentation, return True.
- Otherwise, backtrack and try other splits.

â±ï¸ Time Complexity: Exponential, O(2â¿), where n = len(s)  
ğŸ§  Space Complexity: O(n) for recursion depth

---

ğŸ’¡ Optimized Approach (Trie + DFS + Memoization):

âœ… Strategy:
- Insert all dictionary words into a Trie for efficient prefix lookup.
- Use DFS to check for valid word splits starting from index 0.
- At each step, match the current prefix using the Trie.
- If a word ends at the current index, recursively check the suffix.
- Use memoization to cache results for previously computed indices.

â±ï¸ Time Complexity: O(nÂ²) in the worst case (with memoization)  
ğŸ§  Space Complexity: O(n) for recursion + O(n) for memoization

---

ğŸš€ Code Trace Example:

s = "leetcode", wordDict = ["leet", "code"]  

Trie:
              (root)
             /      \
            l        c
            |        |
            e        o
            |        |
            e        d
            |        |
            tâ—       eâ—


- Start at index 0:  
  - "l" â†’ "le" â†’ "lee" â†’ "leet" âœ… (found in Trie) â†’ dfs(4)  
- Start at index 4:  
  - "c" â†’ "co" â†’ "cod" â†’ "code" âœ… â†’ dfs(8)  
- index == len(s) â†’ return True

ğŸ Final Answer: True

---
