LeetCode #169 - Majority Element  
https://leetcode.com/problems/majority-element/

ğŸ§© Problem:
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than âŒŠn / 2âŒ‹ times.
You may assume that the majority element always exists in the array.

ğŸ“¥ Examples:
Input: nums = [3,2,3]
Output: 3

Input: nums = [2,2,1,1,1,2,2]
Output: 2

---

âœ… Brute Force Approach using Hash Map

ğŸ” Idea:
Use a dictionary (hash map) to count the frequency of each element. Return the element that appears more than n/2 times.

ğŸ§  Pseudocode:
- Initialize an empty dictionary `frequency_map`
- For each element `num` in nums:
    - If num not in frequency_map:
        - frequency_map[num] = 1
    - Else:
        - frequency_map[num] += 1
- For each key, value pair in frequency_map:
    - If value > n // 2:
        - Return key

â±ï¸ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(n)

---

âœ… Optimized Approach: Boyer-Moore Voting Algorithm

ğŸ” Idea:
The Boyer-Moore Voting Algorithm efficiently finds the majority element in linear time and constant space.

**How it works:**
- Use a variable `candidate` for the potential majority element and `count` to track its frequency.
- Loop through the array:
    - If count is 0, assign current element to `candidate`.
    - If current element equals `candidate`, increment count.
    - Else, decrement count.
- The final `candidate` will be the majority element because it occurs more than n/2 times.

ğŸ§  Pseudocode:
- Initialize: count = 0, candidate = None
- For each number in nums:
    - If count == 0:
        - candidate = number
    - If number == candidate:
        - count += 1
    - Else:
        - count -= 1
- Return candidate

â±ï¸ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(1)

---

âœ… Trace of Boyer-Moore Voting Algorithm

Input: [2,2,1,1,1,2,2]

Step-by-step:

- count = 0, candidate = None  
- num = 2 â†’ count = 0 â†’ candidate = 2 â†’ count = 1  
- num = 2 â†’ same â†’ count = 2  
- num = 1 â†’ different â†’ count = 1  
- num = 1 â†’ different â†’ count = 0  
- num = 1 â†’ count = 0 â†’ candidate = 1 â†’ count = 1  
- num = 2 â†’ different â†’ count = 0  
- num = 2 â†’ count = 0 â†’ candidate = 2 â†’ count = 1  

âœ… Final candidate: 2 â†’ Output: 2
