LeetCode - Palindrome Linked List  
https://leetcode.com/problems/palindrome-linked-list/

ðŸ§© Problem:  
Given the head of a singly linked list, determine if the linked list is a palindrome.

A palindrome linked list reads the same forwards and backwards.

ðŸ“¥ Example:  
Input: 1 -> 2 -> 2 -> 1  
Output: True

Input: 1 -> 2  
Output: False

---

âœ… Brute Force Approach

ðŸ” Idea:  
* Traverse the linked list once and push all node values onto a stack (or list).  
* Traverse the linked list again and compare each node's value with the value popped from the stack.  
* If all values match, the list is palindrome; otherwise, it is not.

ðŸ§  Pseudocode:  
function isPalindrome(head):  
â€ƒif head is None or head.next is None:  
â€ƒâ€ƒreturn True  
â€ƒstack = []  
â€ƒcurrent = head  
â€ƒwhile current is not None:  
â€ƒâ€ƒstack.push(current.val)  
â€ƒâ€ƒcurrent = current.next  
â€ƒcurrent = head  
â€ƒwhile current is not None:  
â€ƒâ€ƒif stack.pop() != current.val:  
â€ƒâ€ƒâ€ƒreturn False  
â€ƒâ€ƒcurrent = current.next  
â€ƒreturn True

â±ï¸ Time Complexity: O(n) â€” traverse list twice  
ðŸ§  Space Complexity: O(n) â€” for the stack storing all node values

---

âœ… Optimized Approach (Using Fast and Slow Pointer + Reversing Half)

ðŸ” Explanation:  
* Use two pointers (fast and slow) to find the middle of the list.  
* Reverse the second half of the list.  
* Compare the first half and reversed second half node-by-node.  
* Restore the list (optional).  
* Return true if all nodes match, else false.

â±ï¸ Time Complexity: O(n) â€” single pass to find middle, reverse half, and compare  
ðŸ§  Space Complexity: O(1) â€” in-place reversal, no extra stack

---

âœ… Trace Example (Partial)

Input List:  
1 -> 2 -> 2 -> 1

Step 1: Find middle (slow at second 2)  
Step 2: Reverse second half (2 -> 1 becomes 1 -> 2)  
Step 3: Compare first half 1 -> 2 with reversed second half 1 -> 2  
Step 4: All nodes match, so return True
