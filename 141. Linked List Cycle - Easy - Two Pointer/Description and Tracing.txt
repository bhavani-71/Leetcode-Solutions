LeetCode #141 - Linked List Cycle - https://leetcode.com/problems/linked-list-cycle/

Given head, the head of a linked list, determine if the linked list has a cycle in it.

A cycle exists if there is a node in the list that can be reached again by continuously following the next pointer.

Return true if there is a cycle in the linked list. Otherwise, return false.

Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: The tail connects to the second node (index 1).

Example 2:
Input: head = [1,2], pos = 0
Output: true
Explanation: The tail connects to the first node (index 0).

Example 3:
Input: head = [1], pos = -1
Output: false
Explanation: No cycle in the list.

ðŸª“ Brute Force Approach

ðŸ” Approach:
Traverse the linked list and store each visited node in a set.

If a node is visited again (exists in the set), it means there is a cycle.

If the traversal reaches the end (None) without repeats, there is no cycle.

ðŸ§  Pseudocode:

visited = empty set
current = head

WHILE current is not None:
    IF current in visited:
        RETURN True
    add current to visited
    current = current.next

RETURN False

â±ï¸ Time Complexity:
O(n) â€” Each node is visited once

ðŸ§  Space Complexity:
O(n) â€” Extra space for the visited set


âœ… Optimized Solution (Floydâ€™s Cycle Detection / Tortoise and Hare Algorithm)

ðŸ” Approach:
Use two pointers moving at different speeds:

- `slow` moves one step at a time.
- `fast` moves two steps at a time.

If there is no cycle, fast pointer will reach the end of the list (None).

If there is a cycle, fast and slow pointers will eventually meet inside the cycle.

â±ï¸ Time Complexity:
O(n) â€” Each node is visited at most once by slow and fast pointers.

ðŸ§  Space Complexity:
O(1) â€” No extra space used except pointers.


âœ… Code Trace

Input:
head = [3, 2, 0, -4], cycle connects tail to node at index 1

ðŸ” Iteration 1:
slow = 3 -> 2  
fast = 3 -> 0 (moves two steps)

slow != fast â†’ continue

ðŸ” Iteration 2:
slow = 2 -> 0  
fast = 0 -> 2 (moves two steps)

slow != fast â†’ continue

ðŸ” Iteration 3:
slow = 0 -> -4  
fast = 2 -> -4 (moves two steps)

slow != fast â†’ continue

ðŸ” Iteration 4:
slow = -4 -> 2  
fast = -4 -> 2 (moves two steps)

slow == fast â†’ cycle detected â†’ return True

âœ… Final Output:
True
