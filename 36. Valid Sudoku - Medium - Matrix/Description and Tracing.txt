https://leetcode.com/problems/valid-sudoku/

ğŸ§© Problem Statement:

Given a 9x9 Sudoku board, determine if it is valid according to Sudoku rules.  
The board can be partially filled and empty cells are represented by '.'.

âœ… Sudoku Rules:
- Each row must contain the digits 1-9 without repetition.
- Each column must contain the digits 1-9 without repetition.
- Each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition.

---

ğŸ’¡ Example:

Input Board (partial):

5 3 . | . 7 . | . . .  
6 . . | 1 9 5 | . . .  
. 9 8 | . . . | . 6 .  
------+------+------  
8 . . | . 6 . | . . 3  
4 . . | 8 . 3 | . . 1  
7 . . | . 2 . | . . 6  
------+------+------  
. 6 . | . . . | 2 8 .  
. . . | 4 1 9 | . . 5  
. . . | . 8 . | . 7 9  

Output: True

Explanation:  
No rows, columns, or 3x3 boxes contain duplicates of the digits filled so far.

---

ğŸª“ Brute Force Approach:

ğŸ” Approach:  
- Check each row for duplicates ignoring '.'  
- Check each column for duplicates  
- Check each 3x3 sub-box for duplicates  
- Return False immediately if any duplicates found, else True after all checks.

â±ï¸ Time Complexity: O(9*9) = O(81) â€” constant time due to fixed board size  
ğŸ§  Space Complexity: O(9*9) for sets to track digits in rows, columns, boxes

---

ğŸš€ Optimized Approach (Single Pass):

âœ… Strategy:  
- Traverse the board once  
- For each digit (not '.'), check if it is already in the respective row, column, or box set  
- If yes, return False  
- Else, add it to corresponding sets  
- If no conflicts, return True at the end

â±ï¸ Time Complexity: O(81) â€” single pass  
ğŸ§  Space Complexity: O(81) â€” sets for rows, columns, boxes

---

ğŸ§© Complete Trace Explanation (Using a partial example for brevity):

Board (partial):

5 3 . | . 7 . | . . .  
6 . . | 1 9 5 | . . .  
. 9 8 | . . . | . 6 .  

---

Initialization:  
- row_sets = [set(), set(), ..., set()] (9 sets for rows)  
- col_sets = [set(), set(), ..., set()] (9 sets for columns)  
- box_sets = [set(), set(), ..., set()] (9 sets for 3x3 boxes)  

---

Iteration:

ğŸŸ¢ i=0, j=0: digit='5'  
- Check row 0: '5' not present â†’ add '5'  
- Check column 0: '5' not present â†’ add '5'  
- Box index = (0//3)*3 + (0//3) = 0 â†’ box 0: '5' not present â†’ add '5'  
row_sets[0] = {'5'}  
col_sets[0] = {'5'}  
box_sets[0] = {'5'}  

ğŸŸ¢ i=0, j=1: digit='3'  
- row 0: '3' not present â†’ add '3'  
- col 1: '3' not present â†’ add '3'  
- box 0: '3' not present â†’ add '3'  
row_sets[0] = {'5','3'}  
col_sets[1] = {'3'}  
box_sets[0] = {'5','3'}  

âšª i=0, j=2: digit='.' skip  

ğŸŸ¢ i=0, j=4: digit='7'  
- row 0: '7' not present â†’ add '7'  
- col 4: '7' not present â†’ add '7'  
- box 1: (0//3)*3 + (4//3) = 1 â†’ '7' not present â†’ add '7'  
row_sets[0] = {'5','3','7'}  
col_sets[4] = {'7'}  
box_sets[1] = {'7'}  

ğŸŸ¢ i=1, j=0: digit='6'  
- row 1: '6' not present â†’ add '6'  
- col 0: '6' not present â†’ add '6'  
- box 0: '6' not present â†’ add '6'  
row_sets[1] = {'6'}  
col_sets[0] = {'5','6'}  
box_sets[0] = {'5','3','6'}  

âšª i=1, j=1: '.' skip  
âšª i=1, j=2: '.' skip  

ğŸŸ¢ i=1, j=3: digit='1'  
- row 1: '1' not present â†’ add '1'  
- col 3: '1' not present â†’ add '1'  
- box 1: '1' not present â†’ add '1'  
row_sets[1] = {'6','1'}  
col_sets[3] = {'1'}  
box_sets[1] = {'7','1'}  

ğŸŸ¢ i=1, j=4: digit='9'  
- row 1: '9' not present â†’ add '9'  
- col 4: '9' not present â†’ add '9'  
- box 1: '9' not present â†’ add '9'  
row_sets[1] = {'6','1','9'}  
col_sets[4] = {'7','9'}  
box_sets[1] = {'7','1','9'}  

ğŸŸ¢ i=1, j=5: digit='5'  
- row 1: '5' not present â†’ add '5'  
- col 5: '5' not present â†’ add '5'  
- box 1: '5' not present â†’ add '5'  
row_sets[1] = {'6','1','9','5'}  
col_sets[5] = {'5'}  
box_sets[1] = {'7','1','9','5'}  

âšª i=1, j=6: '.' skip  
âšª i=1, j=7: '.' skip  
âšª i=1, j=8: '.' skip  

ğŸŸ¢ i=2, j=1: digit='9'  
- row 2: '9' not present â†’ add '9'  
- col 1: '9' not present â†’ add '9'  
- box 0: '9' not present â†’ add '9'  
row_sets[2] = {'9'}  
col_sets[1] = {'3','9'}  
box_sets[0] = {'5','3','6','9'}  

ğŸŸ¢ i=2, j=2: digit='8'  
- row 2: '8' not present â†’ add '8'  
- col 2: '8' not present â†’ add '8'  
- box 0: '8' not present â†’ add '8'  
row_sets[2] = {'9','8'}  
col_sets[2] = {'8'}  
box_sets[0] = {'5','3','6','9','8'}  

âšª i=2, j=3 to j=8: '.' or other digits handled similarly  

---

âŒ Example of invalid case:  
If at any point a digit is already in the respective set:  
e.g., if at i=0, j=1 digit='5' and '5' already exists in row_sets[0], return False immediately.

---

âœ… If all cells checked with no conflicts â†’ return True indicating the Sudoku board is valid.
