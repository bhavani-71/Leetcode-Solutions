LeetCode #704 - Binary Search  
https://leetcode.com/problems/binary-search/

ğŸ§© Problem:
Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, return the index of the `target` if it is in the array.  
If not, return -1.

You must write an algorithm with O(log n) runtime complexity.

ğŸ“¥ Examples:
Input: nums = [-1,0,3,5,9,12], target = 9  
Output: 4

Input: nums = [-1,0,3,5,9,12], target = 2  
Output: -1

---

âœ… Brute Force Approach

ğŸ” Idea:
- Linearly scan each element in the array and check if it's equal to the target.

ğŸ§  Pseudocode:
- Loop from index 0 to n-1:
    - If nums[i] == target: return i
- Return -1

â±ï¸ Time Complexity: O(n)  
ğŸ§  Space Complexity: O(1)  

---

âœ… Optimized Approach Using Binary Search

ğŸ” Idea:
- Since the array is sorted, we can repeatedly divide the search space in half.

ğŸ§  Conditions:
- If middle element equals the target â†’ return index.
- If middle element is less than target â†’ discard left half.
- If middle element is greater than target â†’ discard right half.

ğŸ§  Pseudocode:
- Initialize `left = 0`, `right = n - 1`
- While left â‰¤ right:
    - mid = (left + right) // 2
    - if nums[mid] == target â†’ return mid
    - if nums[mid] < target â†’ search right half (`left = mid + 1`)
    - else â†’ search left half (`right = mid - 1`)
- Return -1

â±ï¸ Time Complexity: O(log n)  
ğŸ§  Space Complexity: O(1)

---

âœ… Trace Example

Input: nums = [-1,0,3,5,9,12], target = 9  
Initial: left = 0, right = 5  

â†’ mid = 2 â†’ nums[2] = 3 < 9 â†’ left = 3  
â†’ mid = 4 â†’ nums[4] = 9 == 9 â†’ return 4

âœ… Output: 4
