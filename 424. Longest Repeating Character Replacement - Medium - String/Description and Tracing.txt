description: |
  ğŸ“˜ LeetCode: Longest Repeating Character Replacement  
  ğŸ“Œ Title: Longest Repeating Character Replacement  
  ğŸ”— Link: https://leetcode.com/problems/longest-repeating-character-replacement/

  ğŸ§© Problem Statement:  
  Given a string `s` and an integer `k`, you can replace at most `k` characters in the string to get the longest substring with all repeating characters. Return the length of the longest such substring.

  ğŸ§± Components:  
  - Input:  
    - `s`: a string consisting of uppercase English letters  
    - `k`: integer representing maximum allowed replacements  
  - Output: Length of the longest substring with repeating characters after up to `k` replacements  
  - Data Structure: Sliding Window + HashMap (dictionary) to track frequencies

  ğŸ’¡ Brute Force Approach:  
  - Consider every possible substring of `s`  
  - For each substring, count the frequency of each character  
  - Calculate the number of characters that need to be replaced to make the substring all the same character  
  - If the replacements needed are â‰¤ `k`, update the max length  
  - âŒ Time complexity O(NÂ³) (checking all substrings and counting frequencies) â€” inefficient for large strings

  ğŸš€ Optimized Approach (Sliding Window + Frequency Counting):  
  - Use two pointers `l` and `i` to maintain a sliding window  
  - Maintain frequency of chars in current window and track max frequency  
  - If window size minus max frequency > `k`, shrink window from left  
  - Keep track of max window length seen so far

  â±ï¸ Time Complexity: O(N), N = length of s (each character visited at most twice)  
  ğŸ§  Space Complexity: O(1), since dictionary stores max 26 characters (English uppercase)

detailed_trace: |
  Example:  
  s = "AABABBA", k = 1

  Initialize:  
  - ğŸ‘ˆ left = 0, max_freq = 0, max_length = 0  
  - ğŸ“Š frequency_dict = {}

  Iterate over s with right pointer (i):  

  i=0 ('A'):  
  - ğŸ“Š frequency_dict = {'A':1}  
  - ğŸ” max_freq = 1 (max frequency in window)  
  - ğŸ”¢ window size = 1, replacements needed = 1 - 1 = 0 â‰¤ k(1) âœ… valid  
  - ğŸ“ˆ max_length = 1  

  i=1 ('A'):  
  - ğŸ“Š frequency_dict = {'A':2}  
  - ğŸ” max_freq = 2  
  - ğŸ”¢ window size = 2, replacements needed = 2 - 2 = 0 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 2  

  i=2 ('B'):  
  - ğŸ“Š frequency_dict = {'A':2, 'B':1}  
  - ğŸ” max_freq = 2 (still 'A')  
  - ğŸ”¢ window size = 3, replacements needed = 3 - 2 = 1 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 3  

  i=3 ('A'):  
  - ğŸ“Š frequency_dict = {'A':3, 'B':1}  
  - ğŸ” max_freq = 3  
  - ğŸ”¢ window size = 4, replacements needed = 4 - 3 = 1 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 4  

  i=4 ('B'):  
  - ğŸ“Š frequency_dict = {'A':3, 'B':2}  
  - ğŸ” max_freq = 3  
  - ğŸ”¢ window size = 5, replacements needed = 5 - 3 = 2 > k(1) âŒ invalid  
  - ğŸ”„ Shrink window from left:  
    - â– frequency_dict['A'] = 2  
    - ğŸ‘ˆ left = 1  
  - ğŸ”¢ window size = 4, replacements = 4 - 3 = 1 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 4  

  i=5 ('B'):  
  - ğŸ“Š frequency_dict = {'A':2, 'B':3}  
  - ğŸ” max_freq = 3 ('B')  
  - ğŸ”¢ window size = 5, replacements = 5 - 3 = 2 > 1 âŒ invalid  
  - ğŸ”„ Shrink window from left:  
    - â– frequency_dict['A'] = 1  
    - ğŸ‘ˆ left = 2  
  - ğŸ”¢ window size = 4, replacements = 4 - 3 = 1 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 4  

  i=6 ('A'):  
  - ğŸ“Š frequency_dict = {'A':2, 'B':3}  
  - ğŸ” max_freq = 3 ('B')  
  - ğŸ”¢ window size = 5, replacements = 5 - 3 = 2 > 1 âŒ invalid  
  - ğŸ”„ Shrink window from left:  
    - â– frequency_dict['B'] = 2  
    - ğŸ‘ˆ left = 3  
  - ğŸ”¢ window size = 4, replacements = 4 - 2 = 2 > 1 âŒ still invalid  
  - ğŸ”„ Shrink window again:  
    - â– frequency_dict['A'] = 1  
    - ğŸ‘ˆ left = 4  
  - ğŸ”¢ window size = 3, replacements = 3 - 2 = 1 â‰¤ 1 âœ… valid  
  - ğŸ“ˆ max_length = 4  

ğŸ¯ Result:  
Longest valid substring length is 4.

ğŸ’¡ Explanation:  
- Substrings like "AABA" or "ABBB" can be formed by replacing at most one character to have all repeating characters.

