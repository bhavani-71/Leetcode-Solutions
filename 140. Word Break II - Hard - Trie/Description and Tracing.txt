ğŸ”— LeetCode: 140  
ğŸ“Œ Title: Word Break II  
ğŸ”— Link: https://leetcode.com/problems/word-break-ii

ğŸ§© Problem Statement:  
Given a string `s` and a list of words `wordDict`, return **all possible sentences** where `s` can be segmented into a space-separated sequence of one or more dictionary words.  
Each word in the dictionary can be reused any number of times.

ğŸª“ Brute Force Approach (DFS without memoization):  
ğŸ” Idea:
- Try every possible prefix of the string `s`.
- If the prefix exists in `wordDict`, recursively try to break the remaining string.
- Combine results by appending the prefix to results of the recursive calls.
- Very inefficient due to repeated work for same substrings.

ğŸ” Steps:
1. For each index `i`, consider all substrings `s[ind:i+1]`.
2. If substring is in dictionary, recursively solve for `i+1`.
3. Concatenate valid results to form full sentences.

â±ï¸ Time Complexity: O(2^n) â€” Exponential due to overlapping recursive calls  
ğŸ§  Space Complexity: O(n) for recursion stack

âš¡ Optimized Approach (Trie + DFS + Memoization):  
ğŸ” Idea:
- Use a Trie to check if substrings exist in `wordDict` efficiently.
- Apply DFS with memoization to avoid recalculating solutions for the same start index.
- Store computed results for each index in a cache.

ğŸ” Steps:
1. Insert all dictionary words into a Trie.
2. Use DFS from index 0 of the string.
3. At each step, traverse the Trie while matching characters in the string.
4. If a valid word is found, recursively process the remaining substring.
5. Use a `cache` dictionary to store and reuse results for each index.

â±ï¸ Time Complexity: O(n^2 * m) â€” where n = len(s), m = number of words in `wordDict`  
ğŸ§  Space Complexity: O(n^2) for memoization and output + Trie space

ğŸ”š Result:
This optimized solution is significantly faster than brute force for large inputs and avoids redundant computation by caching.

ğŸ§ª Trace for s = "catsanddog", wordDict = ["cat", "cats", "and", "sand", "dog"]
(root)
 â”œâ”€â”€ c
 â”‚   â””â”€â”€ a
 â”‚       â””â”€â”€ t âœ”
 â”‚           â””â”€â”€ s âœ”
 â”œâ”€â”€ a
 â”‚   â””â”€â”€ n
 â”‚       â””â”€â”€ d âœ”
 â”œâ”€â”€ s
 â”‚   â””â”€â”€ a
 â”‚       â””â”€â”€ n
 â”‚           â””â”€â”€ d âœ”
 â””â”€â”€ d
     â””â”€â”€ o
         â””â”€â”€ g âœ”

ğŸ¾ Step 1: Build Trie with words: "cat", "cats", "and", "sand", "dog"

ğŸ“ Start DFS from index 0:
ğŸ” Check substrings starting from index 0
1ï¸âƒ£ chars: 'c' â¡ï¸ in trie  
2ï¸âƒ£ chars: 'a' â¡ï¸ in trie  
3ï¸âƒ£ chars: 't' â¡ï¸ "cat" is a word  
  â¤µï¸ Recurse from index 3
    - Check 's', 'a', 'n', 'd' â†’ "sand" is a word  
      â¤µï¸ Recurse from index 7  
        - Check 'd', 'o', 'g' â†’ "dog" is a word  
        âœ… Sentence found: "cat sand dog"

ğŸ” Backtrack to index 0  
4ï¸âƒ£ chars: 's' â¡ï¸ invalid, stop path  

ğŸ” Retry prefix: "cats"
- "cats" is a word  
  â¤µï¸ Recurse from index 4  
    - Check 'a', 'n', 'd' â†’ "and" is a word  
      â¤µï¸ Recurse from index 7  
        - Check 'd', 'o', 'g' â†’ "dog" is a word  
        âœ… Sentence found: "cats and dog"

âœ… Final Result: ["cat sand dog", "cats and dog"]

