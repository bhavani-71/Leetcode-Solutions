description: |
  ğŸŒ Problem Statement:  
  You are given a network of `n` servers labeled from 0 to `n-1`. The network connections are represented as a list of pairs `[u, v]`, indicating a bidirectional connection between servers `u` and `v`.  

  A critical connection is an edge that, if removed, will increase the number of disconnected components in the network. In other words, removing this connection will disconnect some servers from others.  

  Your task is to find all such critical connections in the network.

  ğŸ“Œ Example:  
  Consider `n = 4` servers and connections: `[[0,1], [1,2], [2,0], [1,3]]`.  

  The network looks like:  


  0
 / \
1---2
|
3

- Servers `0, 1, 2` form a cycle, so removing any edge between them still keeps the network connected.  
- The connection `[1, 3]` connects server `3` to the rest. Removing `[1, 3]` isolates server `3`.  
Therefore, the critical connection is `[[1, 3]]`.

ğŸ§© Input:  
- `n`: integer, number of servers  
- `connections`: list of pairs representing connections  

ğŸ“¤ Output:  
- List of all critical connections (edges) that disconnect the network if removed.

ğŸ’¡ Brute Force Approach:  
- For each connection, remove it from the network.  
- Check if the network remains fully connected by running DFS/BFS.  
- If removing the connection disconnects the graph, add it to the critical connections list.  
- âŒ Time Complexity: O(E * (V + E)) where E is number of edges and V is number of vertices â€” inefficient for large networks.

ğŸš€ Optimized Approach (Tarjanâ€™s Algorithm for Bridges):  
- Use DFS to assign each node a discovery time and low-link value.  
- The low-link value of a node represents the earliest visited vertex reachable from that node or its descendants.  
- An edge `(u, v)` is critical if `low[v] > disc[u]`, meaning no back edge connects `v` or its descendants back to `u` or earlier nodes.  
- Run DFS from each unvisited node to find all critical edges efficiently.  

â±ï¸ Time Complexity: O(V + E) â€” each node and edge visited once  
ğŸ§  Space Complexity: O(V + E) for adjacency and auxiliary arrays


detailed_trace_with_emojis: |
  Example:  
  n = 4  
  connections = [[0,1], [1,2], [2,0], [1,3]]

  Step 1ï¸âƒ£: Build adjacency list:  

Step-by-step:  
- Build adjacency list:  
  0: [1,2]  
  1: [0,2,3]  
  2: [1,0]  
  3: [1]

 - Initial:  
    disc = [-1, -1, -1, -1]  
    low = [-1, -1, -1, -1]  
    time = 0ï¸âƒ£  
    result = []

  - Step 1ï¸âƒ£: DFS starts at node 0  
    disc[0] = low[0] = 0ï¸âƒ£, time â†’ 1ï¸âƒ£  

  - Step 2ï¸âƒ£: Visit neighbors of 0 â†’ node 1  
    disc[1] = low[1] = 1ï¸âƒ£, time â†’ 2ï¸âƒ£  

  - Step 3ï¸âƒ£: Visit neighbors of 1  
    Skip parent 0 ğŸš«  
    Visit neighbor 2  

  - Step 4ï¸âƒ£: Visit neighbors of 2  
    disc[2] = low[2] = 2ï¸âƒ£, time â†’ 3ï¸âƒ£  
    Skip parent 1 ğŸš«  
    Neighbor 0 visited â†’ update low[2] = min(2ï¸âƒ£, 0ï¸âƒ£) = 0ï¸âƒ£  

  - Step 5ï¸âƒ£: End DFS for 2  
    Update low[1] = min(1ï¸âƒ£, 0ï¸âƒ£) = 0ï¸âƒ£  

  - Step 6ï¸âƒ£: Back to 1 â†’ visit neighbor 3  
    disc[3] = low[3] = 3ï¸âƒ£, time â†’ 4ï¸âƒ£  

  - Step 7ï¸âƒ£: Visit neighbors of 3  
    Skip parent 1 ğŸš«  

  - Step 8ï¸âƒ£: End DFS for 3  
    Update low[1] = min(0ï¸âƒ£, 3ï¸âƒ£) = 0ï¸âƒ£  

  - Step 9ï¸âƒ£: Check if edge (1,3) is critical  
    low[3] (3ï¸âƒ£) > disc[1] (1ï¸âƒ£) â†’ Yes âœ…  
    Add [1, 3] to result  

  - Step ğŸ”Ÿ: End DFS for 1  
    Update low[0] = min(0ï¸âƒ£, 0ï¸âƒ£) = 0ï¸âƒ£  

  - Step 1ï¸âƒ£1ï¸âƒ£: End DFS for 0  
    All nodes visited  

  **Final critical connections:** [[1, 3]] 

ğŸ¯ Summary:
The algorithm finds edges whose removal increases network disconnectivity by using discovery and low-link values during DFS traversal, making it efficient and suitable for large graphs.
